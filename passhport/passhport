#!/usr/bin/env python
# -*- coding:Utf-8 -*-

# Compatibility 2.7-3.4
from __future__ import absolute_import
from __future__ import unicode_literals
from builtins import input
from datetime import datetime

import os, sys, locale, requests, random, crypt, re

from connections_utils import ssh
from connections_utils import scp
from connections_utils import password

SCRIPT_LOGS_PATH="/var/log/passhport"
PWD_RST_AFTER_SESSION=False
PWD_FILE_DIR="/home/passhport/.access_codes"

def get(url):
    """Send the GET request to the server and print a result.
       This is used to connect to passhportd, to check access"""
    try:
        r = requests.get(url)
    except requests.RequestException as e:
        print("ERROR: " + str(e.message))
    else:
        if r.status_code == requests.codes.ok:
            return r.text

    return 1


def checkandconnect(indexed_target_list, choice, username, originalcmd):
    """Check if the user have entered an accessible target
       then check target type and launch the action"""

    # Check the target access and access type
    for line in indexed_target_list:
        item_list = line.split(" ")
        if choice in item_list:
            if len(item_list) > 2:
                target = item_list[2]
                pathlog = SCRIPT_LOGS_PATH + "/" + target + "/"
                isodate = datetime.now().isoformat().replace(":",""). \
                          replace("-","").split('.')[0]
                filelog = pathlog + isodate + "-" + str(os.getpid()) + "-" + \
                          target + "-" + username
                login = get(url_passhport + "target" + "/login/" +  
                        item_list[1])
                sshoptions = get(url_passhport + "target" + "/sshoptions/" + \
                             item_list[1])

                # Create a log directory for this target
                if not os.path.exists(pathlog):
                    os.mkdir(pathlog)

                # It's SCP if originalcmd is set, else ssh.
                if originalcmd: 
                    scp.connect(target, filelog, login, sshoptions, originalcmd)
                else:
                    ssh.connect(target, filelog, login, sshoptions)

                # Change password on the target
                if PWD_RST_AFTER_SESSION:
                    password.reset(target, login, sshoptions)

                return True
            else:
                print("Error on target definition")
        
    return False


def build_target_list(target_list, tabulations=0):
    """Print the targets list in a readable listed numbered list format"""
    indexed_target_list = []
    number = 1
    for each_target in target_list:
        if not tabulations:
            indexed_target_list.append(str(number) + " " + each_target)
        else:
            indexed_target_list.append(str(number) + " " + \
                                each_target.replace(" "," \t\t"))
        number = number + 1

    return indexed_target_list


### MAIN ###
if __name__ == '__main__':
    username = sys.argv[1]
    url_passhport = "http://127.0.0.1:5000/"
    target_list = get(url_passhport + "user" + "/accessible_targets/" + \
                  username, verify='/home/passhport/certs/cert.pem').split("\n")
    originalcmd = os.environ.get('SSH_ORIGINAL_COMMAND')
    choice = 0
 
    # If the user can't access any target
    if target_list == [u'']:
        sys.exit("Sorry you can't access any server") 

    #Construct the indexted targets list
    indexed_target_list = build_target_list(target_list)

    # Check if it's pure ssh or another type of connection:
    if originalcmd:
        # In case the SSH_ORIGINAL_COMMAND is set,
        # it should be scp/rsync (according to sshd manpage)
        # Determine the target parsing the originalcmd
        parsedcommand = scp.parse(originalcmd)
        if len(parsedcommand) > 1:
            choice = parsedcommand[0] # the target
            command = parsedcommand[1] # the rewrited command
            checkandconnect(indexed_target_list, choice, username, command)
        else:
            sys.exit("Syntax error on the command.")
    else:
        # We handle the ssh connection
        print("Welcome {}.".format(username))
        print("Here is the list of servers you can access:")

        # Print servers the user can access, with a blank line between each entry
        print(*build_target_list(target_list, tabulations=1), sep='\n')

        # Let the use chose his server
        sys.stdout.write("Type the number, name or hostname of the server you want to connect to : ")
        choice = input("")
        valid_input = False

        # Try to connect the user to the server he choosed or ask to re-type
        while not checkandconnect(indexed_target_list, choice, username, originalcmd):
            print("You didn't type correctly, please try again.")
            sys.stdout.write("Type the number, name or hostname of the server you want to connect to : ")
            choice = input("")
